# -*- coding: utf-8 -*-
"""conception.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ELNNWFO0DTOkDXuXbgX2MFyadkMRzeIA
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""#bouchon"""

r0=31/2
R=list()
while r0>16/2:
  R.append(r0)
  r0-=0.5
R.append(r0)
print(R)

List_R=R

import math

epsilon=list()
for r in List_R:
  epsilon.append(math.log(r/15.5))
print(epsilon)

import numpy as np

array_R=np.asarray(List_R)
array_epsilon=np.asarray(epsilon)

P=39.5*array_epsilon**(3)-28*array_epsilon**2+8.9*array_epsilon

print(P)

F=P*50*np.math.sqrt(2)*array_R

print(F)

table=np.asarray([array_R,array_epsilon,P,F])

import pandas as pd

df=pd.DataFrame(table)

df=df.transpose()

print(df)
plt.show()

"""#Loi de levée"""

import numpy as np
import matplotlib.pyplot as plt

theta=np.linspace(0,2*np.pi,100)
theta0=0
w=3.14
t=(theta-theta0)/w
print((2*np.pi)/w)

print(t)

S=30            #smax
t1=0.45      #les temps dans le chronogramme
t2=1.03
t3=1.48
t4=2
T=t1/2
a=592.2
s1=[1/2 *a*tt**2 for tt in t  if tt<=t1/2] #montée
s2=[-1/2*a*tt**2 +a*t1*tt- 1/2*a*t1**2 + S for tt in t  if tt>t1/2 and tt<=t1] #montée
s3=[S for tt in t  if tt>t1 and tt<=t2]
s4=[-a*(tt**2 /2 -t2*tt)+S-a*t2**2/2 for tt in t  if tt>t2 and tt<=t2+T] #descente
s5=[1/2*a*tt**2 -a*t3*tt+ 1/2*a*t3**2  for tt in t  if tt>t2+T and tt<=t3] #montée
s6=[0 for tt in t  if tt>t3]

s=[s1,s2,s3,s4,s5,s6]
svide=[]
for si in s:
  for elt in si:
    svide.append(elt)

svide=np.array(svide)

ds=np.array([(svide[i]-svide[i-1])/(t[i]-t[i-1]) for i in range(len(svide))])
dds=np.array([(ds[i]-ds[i-1])/(t[i]-t[i-1]) for i in range(len(ds))])
ddds=np.array([(dds[i]-dds[i-1])/(t[i]-t[i-1]) for i in range(len(dds))])

plt.figure(figsize=(15,15))

plt.subplot(411)
plt.grid()
plt.title("Déplacement")
plt.plot(t, svide,c='g')

plt.subplot(412)
plt.title("Vitesse")
plt.plot(t, ds,c='r')
plt.grid()

plt.subplot(413)
plt.title("Accéleration")
plt.plot(t, dds)
plt.grid()

plt.subplot(414)
plt.title("Impulsion")
plt.plot(t, ddds, c='purple')
plt.grid()


plt.show()

condition= -ds+25*svide
plt.plot(t,condition)
print("Max de ds(t)/dt +25*s(t) =",max(condition))
if(max(condition)<55.66*S):
  print("Condition de loi de levée est validé . on a ds(t)/dt +25*s(t) < 55.66 * Smax ")
else:
  print("Il faut choisir une autre loi")

"""#Dimensionnement arbre Commande

Cet arbre est en acier doux de limite élastique  = 280 MPa. G= 80000MPa

On prendra un coefficient de sécurité de 2 et on imposera un angle de torsion unitaire maximal de 0.25 deg/m.
"""

def diametre_arbre(Fn,f,sigmae,G,s,alpha,Rmax):
  #calcul prelim
  Ft=f*Fn
  Cmax=Rmax*Ft #N*mm
  tu=sigmae/(2*s)
  alpha=alpha*(np.pi/180)*10**-3  #rad/mm
  #condition de résistance
  D1min=(16*Cmax/(np.pi*tu))**(1/3)
  D2min=(32*Cmax/(np.pi*G*alpha))**(1/4)
  return max(D2min,D1min)

"""Comme methode d'optimisation:
On va pouvoir varier le Rmax pour touver la bonne combinaison Rmax,Dmin pour notre systeme

Vu que diametre mini du trou de la came depend de rayon maxi de la came et on a une seule equation  (2 inconnue et une equation)


le but c'est de varier Rmax pour trouver un Dmin hypothetique qui va donner un autre Rayon maxi de la came et le comparer à Rmaxet enfin choisir les bonnes valeurs pour le diametre du trou.


Rayon de base = diametre du trou +10 mm
"""

Force_poussoir=8362
Co_frottement=0.2
sigmae=280
G=80000
angle_torsion=0.25
co_securite=2

#####################################################

Rmax=np.linspace(10+15+30,65,1000)

Dmin=list()
for r in Rmax:
  Dmin.append(diametre_arbre(Force_poussoir,Co_frottement,sigmae,G,co_securite,angle_torsion,r))
Dmin=np.array(Dmin)

RayonBase=Dmin/2+10
rayonmaxi=RayonBase+30
plt.figure(figsize=(10,10))
plt.plot(Rmax,Dmin,label="Dmin ou Diametre Abre")
plt.plot(Rmax,RayonBase,label="Rayon de base came")
plt.plot(Rmax,rayonmaxi, label= "rayon maxi de la came en sortie ")
plt.plot(Rmax,Rmax, label= "rayon maxi de la came en entrée ")
plt.xlabel("Rmax de la came")
plt.legend()
plt.grid()

test=abs(Rmax - rayonmaxi) <= 0.02
i=0
for val in test:
  if val == True:
    Rtrou= ((Rmax[i]+rayonmaxi[i])/2)  - 30 - 10
    print(Rmax[i],'-',rayonmaxi[i],'= +-',abs(Rmax[i]-rayonmaxi[i]), "\n                                                 le rayon du trou est : " ,Rtrou,"\n")
  i+=1
plt.show()
"""Normalement on doit aller avec un rayon de trou de 20.7 mm mais c'est un peu cher en usinage de point de vue precision.


On va chosir un rayon de trou de 20 mm
alors qe le reste de l'abre peut etre superieur à 41.6 en diametre

#Dimensionnement de la clavette (liaison arbre-Came)

La clavette est usinée dans un acier doux dont la pression admissible en fonctionnement est : 
 `Padm = 70MPa.` et `Tadm = limite_élastique_en_traction/2 ` avec un coefficient de sécurité de 2.

 (Tadm= contrainte de cisaillement admissible)
"""

#valeur initial
d_arbre= 40
a=12
b=8
s=0.4
j=d_arbre-5
k = d_arbre + 3.3
Force_poussoir=8362
Co_frottement=0.2
sigmae=280
Padm=80

#fonction calcul
def longueur_clavette(Fn,f,sigmae,s,b,Padm,d_arbre):
  #calcul prelim
  Ft=f*Fn
  Cmax=d_arbre*Ft #N*mm
  tu=sigmae/(2*s)
  #condition de résistance
  l1min=2*Cmax/(a*d_arbre*tu)
  #condition matage
  l2min=4*Cmax/(b*d_arbre*Padm)

  return max(l1min,l2min)

ll= longueur_clavette(Force_poussoir,Co_frottement,sigmae,2,b,Padm,d_arbre)
print("les dimension du clavette en mm sont:\n","largeur=", a,"\n hauteur = ",b, "\n longueur >",ll ,"\n hauteur enlevement matiere sur l'arbre= " ,d_arbre-j,"\n hauteur enlevement matiere sur la came= " ,k-d_arbre )
plt.show()
"""On a trouvé une clavette  `DIN 6885-1 A 12x8x20`  chez Fabory qu'on va utiliser"

#Construction forme Came
"""

Rg=12   #rayon galet
Tc=20  #trou came
Rb=Tc+10  #rayon came (rayon du trou came + 10 mm) 


r1=(Rb+Rg+svide)*np.cos(theta)
r2=(Rb+Rg+svide)*np.sin(theta)

r=(r1**2+r2**2)**(1/2)
rp1=(Rb+svide)*np.cos(theta)
rp2=(Rb+svide)*np.sin(theta)
rprime=(rp1**2+rp2**2)**(1/2)

fig = plt.figure(figsize=(10, 10), dpi=80)

ax = fig.add_subplot(111, projection='polar')
ax.scatter(theta, r,c='r')
ax.scatter(theta, rprime,c='g')
ax.scatter(theta,[Tc]*len(r),c='black')
ax.legend(["theorique","réel","trou"])
plt.show()
"""#Rayon de courbure"""

dr=np.array([(rprime[i]-rprime[i-1])/(theta[i]-theta[i-1]) for i in range(len(rprime))])
ddr=np.array([(dr[i]-dr[i-1])/(theta[i]-theta[i-1]) for i in range(len(dr))])

plt.plot(t,dr)
plt.plot(t,ddr)
plt.show()
temp=(rprime**2+dr**2)**(3/2) 
R= temp/(rprime**2+2*dr**2-rprime*ddr) #rayon de courbure

plt.figure(figsize=(10,9))
plt.plot(t,R)
plt.grid()
plt.show()
Rneg=list()
for r in R:
  if r<=0:
    Rneg.append(r)
    continue
  Rneg.append(0)
  
Rneg=np.array(Rneg)
plt.figure(figsize=(10,9))
plt.plot(t,Rneg)
plt.grid()

Rneg=np.array([r for r in Rneg if r< 0])
print(abs(Rneg))
check = abs(Rneg)>= Rg
print(check)
if(check.all()):
  print( " \n\n **********    La came est validé pour : Rb=",Rb,",Tc=",Tc,",Rg=",Rg, "   ********************")

"""Donc le critére sur le rayon de curbure est validé

#Creation du tableau des coordonnées des points de la Came
"""

import pandas as pd

x=rp1
y=rp2
z=[0]*len(r1)
d={'x':x,'y':y,'z':z}

df= pd.DataFrame(d)
df.head()

open('out.csv','w')
df.to_csv('out.csv',index=False,sep=';')
